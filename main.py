
# Question #1 - Disappeared Numbers (20pts)
# Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear
# twice and others appear once. Find all the elements of [1, n] inclusive that do not
# appear in this array.
# Input: [4,3,2,7,8,2,3,1]
# Output:[5,6]

import numpy as np

nums = np.array([4, 3, 2, 7, 8, 2, 3, 1]) 

def find_disappeared_numbers(nums):
    """
    This function takes an array of integers as the parameter.
    The arange method is used to arrange the array of numbers in order and generate a full array of integers from 1 to n
    The unique method finds all the elements that are not repeating in the array
    """
    numbers_of_array = len(nums)
    full_set = np.arange(1, numbers_of_array + 1)  
    nums_set = np.unique(nums)   
    missing = np.setdiff1d(full_set, nums_set) 
    return missing


missing_numbers = find_disappeared_numbers(nums)
print("Missing numbers:", missing_numbers)



# Question #2 - Pascal Triangle (20pts)
# Given a non-negative integer numRows, generate the first numRows of Pascal's
# triangle. In Pascal's triangle, each number is the sum of the two numbers directly above
# it.
# Input: 5
# Output:
# [
# [1],
# [1,1],
# [1,2,1],
# [1,3,3,1],
# [1,4,6,4,1]
# ]

def generate_pascals_triangle(rows):
    triangle = []
    
    for i in range(rows):
        """
        This function Start a new row with a '1'
        For rows beyond the first row
        the middle values are generated by summing elements from the previous row
        then ending the row with a '1'
        """
        row = [1]  
        if i > 0:     
            for j in range(1, len(triangle[-1])):
                row.append(triangle[-1][j - 1] + triangle[-1][j])
            row.append(1)
        triangle.append(row)
    
    return triangle

def display_pascals_triangle(triangle):
    """
    Use map to turn the rows into strings
    """
    for row in triangle:
        print(" ".join(map(str, row)))  

rows = 6
pascals_triangle = generate_pascals_triangle(rows)
print(pascals_triangle)

display = display_pascals_triangle(pascals_triangle)
print(display)



# Question #3 - Decode String (30pts)
# Given an encoded string, return its decoded string. The encoding rule is:
# k[encoded_string], where the encoded_string inside the square brackets is being
# repeated exactly k times. Note that k is guaranteed to be a positive integer.
# You may assume that the input string is always valid; No extra white spaces, square
# brackets are well-formed, etc. Furthermore, you may assume that the original data does
# not contain any digits and that digits are only for those repeat numbers, k. For example,
# there won't be input like 3a or 2[4].


test_str = "3[a]2[bc]"
stack = []
result = ""

for i in range(len(test_str)):
    """
    The function works by iterating through each character in the string:
    When a digit is encountered, it pushes the digit onto the stack.
    When it encounters an opening bracket '[', it stores the index of the bracket in the stack.
    When there is a closing bracket ']', it pops the index from the stack, extracts the substring between the brackets, and repeats it based on the number found earlier.
    """
    char = test_str[i]
    if char.isdigit():  
        print(char)
        stack.append(int(char))
        print('1',stack)
    if char == "[":
        stack.append(i)
   
    elif char == "]":
        print('stack', stack)
        start = stack.pop()
        content = test_str[start + 1 : i] 
        result += content * start

        print(f"Found nested content: {content}")

print("decoded:", result)



# Question #4 - Intersection of Two Linked Lists (30pts)
# Write a program to find the node at which the intersection of two singly linked lists
# begins. 

class ListNode:
    """
    Represents a node in a singly linked list. Each node contains a value and a reference to the next node.
    """
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def get_length(head):
    """Helper function to calculate the length of the linked list."""
    length = 0
    while head:
        length += 1
        head = head.next
    return length

def get_intersection_node(head1, head2):
    """
    This function gets the lengths of both linked lists.
    Align the starting points of both lists.
    Move head1 by the difference in length
    Move head2 by the difference in length
    Traverse both lists in parallel and check for intersection
    """
 
    len1 = get_length(head1)
    len2 = get_length(head2)

    if len1 > len2:
        
        for _ in range(len1 - len2):
            head1 = head1.next
    elif len2 > len1:
       
        for _ in range(len2 - len1):
            head2 = head2.next

    while head1 and head2:
        if head1 == head2:
            return head1 
        head1 = head1.next
        head2 = head2.next

    return None 


intersection_node = get_intersection_node(list1, list2)

if intersection_node:
    print(f"The intersection node is: {intersection_node.value}")
else:
    print("There is no intersection.")
